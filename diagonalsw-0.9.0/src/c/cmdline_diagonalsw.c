/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  /usr/bin/gengetopt -i /home/hema/Desktop/Hiwi/diagonalsw-0.9.0/src/c/diagonalsw.ggo --file-name=cmdline_diagonalsw --output-dir=/home/hema/Desktop/Hiwi/diagonalsw-0.9.0/src/c

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "cmdline_diagonalsw.h"
const char *gengetopt_args_info_purpose = "A high-performance version of the Smith-Waterman alignment algorithm";

const char *gengetopt_args_info_usage = "Usage: diagonalsw [OPTIONS]...";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help                    Print help and exit",
  "      --version                 Print version and exit",
  "  -d, --databasefile=filename   A FASTA-formatted sequence database file",
  "  -q, --queryfile=filename      A single sequence file in FASTA-format",
  "  -p, --profilefile=filename    A profile file",
  "  -s, --matrixfile=filename     Integer similarity matrix file ( scoring matrix\n                                  )",
  "  -i, --gapopen=INT             Penalty for starting alignment gap\n                                  (non-positive integer)  (default=`-10')",
  "  -e, --gapextend=INT           Penalty for extending alignment gap\n                                  (non-positive integer)  (default=`-2')",
  "  -u, --print-sequence-id       In addition to the score, also print the\n                                  sequence-id  (default=off)",
  "  -V, --verify-algorithm        verify vector implementation against scalar\n                                  implementation  (default=off)",
  "  -D, --disable-threading       disable all threading  (default=off)",
  "  -t, --nr-of-threads=INT       numbers of threads (normally autodetected)",
  "  -T, --tokens-per-thread=INT   numbers of tokens per thread (normally\n                                  autodetected)  (default=`5')",
  "  -W, --sequences-per-compute-chunk=INT\n                                nr of sequences each thread are given per\n                                  computation iteration ( doesn't influence the\n                                  result but may influence the speed )\n                                  (default=`10')",
  "\nbenchmarking:",
  "  To get a more fair benchmark you should run a computation that lasts at least\n  some minutes on a machine that is not under load by other processes.",
  "  -b, --benchmark               print computation speed (unit is GigaCells/s)\n                                  (default=off)",
  "  -B, --benchmark-verbose       print computation speed (unit is GigaCells/s)\n                                  and additional information such as user time,\n                                  number of db sequences that needed to use the\n                                  word sized function, length of querysequence,\n                                  sum of db sequence lengths, number of db\n                                  sequences  (default=off)",
  "\nlimits:",
  "  the default limits should work fine in most cases. Warning: Increasing these\n  values will increase the memory consumption of the program.",
  "  -K, --max-sequence-name-length=INT\n                                Maximum allowed length of a sequence name\n                                  (default=`256')",
  "  -L, --max-query-sequence-length=INT\n                                Maximum allowed length of the query sequence\n                                  (default=`10000000')",
  "  -M, --max-db-sequence-length=INT\n                                Maximum allowed length of any of the db\n                                  sequences  (default=`10000000')",
    0
};

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->databasefile_given = 0 ;
  args_info->queryfile_given = 0 ;
  args_info->profilefile_given = 0 ;
  args_info->matrixfile_given = 0 ;
  args_info->gapopen_given = 0 ;
  args_info->gapextend_given = 0 ;
  args_info->print_sequence_id_given = 0 ;
  args_info->verify_algorithm_given = 0 ;
  args_info->disable_threading_given = 0 ;
  args_info->nr_of_threads_given = 0 ;
  args_info->tokens_per_thread_given = 0 ;
  args_info->sequences_per_compute_chunk_given = 0 ;
  args_info->benchmark_given = 0 ;
  args_info->benchmark_verbose_given = 0 ;
  args_info->max_sequence_name_length_given = 0 ;
  args_info->max_query_sequence_length_given = 0 ;
  args_info->max_db_sequence_length_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->databasefile_arg = NULL;
  args_info->databasefile_orig = NULL;
  args_info->queryfile_arg = NULL;
  args_info->queryfile_orig = NULL;
  args_info->profilefile_arg = NULL;
  args_info->profilefile_orig = NULL;
  args_info->matrixfile_arg = NULL;
  args_info->matrixfile_orig = NULL;
  args_info->gapopen_arg = -10;
  args_info->gapopen_orig = NULL;
  args_info->gapextend_arg = -2;
  args_info->gapextend_orig = NULL;
  args_info->print_sequence_id_flag = 0;
  args_info->verify_algorithm_flag = 0;
  args_info->disable_threading_flag = 0;
  args_info->nr_of_threads_orig = NULL;
  args_info->tokens_per_thread_arg = 5;
  args_info->tokens_per_thread_orig = NULL;
  args_info->sequences_per_compute_chunk_arg = 10;
  args_info->sequences_per_compute_chunk_orig = NULL;
  args_info->benchmark_flag = 0;
  args_info->benchmark_verbose_flag = 0;
  args_info->max_sequence_name_length_arg = 256;
  args_info->max_sequence_name_length_orig = NULL;
  args_info->max_query_sequence_length_arg = 10000000;
  args_info->max_query_sequence_length_orig = NULL;
  args_info->max_db_sequence_length_arg = 10000000;
  args_info->max_db_sequence_length_orig = NULL;

}

static
void init_args_info(struct gengetopt_args_info *args_info)
{


  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->databasefile_help = gengetopt_args_info_help[2] ;
  args_info->queryfile_help = gengetopt_args_info_help[3] ;
  args_info->profilefile_help = gengetopt_args_info_help[4] ;
  args_info->matrixfile_help = gengetopt_args_info_help[5] ;
  args_info->gapopen_help = gengetopt_args_info_help[6] ;
  args_info->gapextend_help = gengetopt_args_info_help[7] ;
  args_info->print_sequence_id_help = gengetopt_args_info_help[8] ;
  args_info->verify_algorithm_help = gengetopt_args_info_help[9] ;
  args_info->disable_threading_help = gengetopt_args_info_help[10] ;
  args_info->nr_of_threads_help = gengetopt_args_info_help[11] ;
  args_info->tokens_per_thread_help = gengetopt_args_info_help[12] ;
  args_info->sequences_per_compute_chunk_help = gengetopt_args_info_help[13] ;
  args_info->benchmark_help = gengetopt_args_info_help[16] ;
  args_info->benchmark_verbose_help = gengetopt_args_info_help[17] ;
  args_info->max_sequence_name_length_help = gengetopt_args_info_help[20] ;
  args_info->max_query_sequence_length_help = gengetopt_args_info_help[21] ;
  args_info->max_db_sequence_length_help = gengetopt_args_info_help[22] ;

}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    {
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params =
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{

  free_string_field (&(args_info->databasefile_arg));
  free_string_field (&(args_info->databasefile_orig));
  free_string_field (&(args_info->queryfile_arg));
  free_string_field (&(args_info->queryfile_orig));
  free_string_field (&(args_info->profilefile_arg));
  free_string_field (&(args_info->profilefile_orig));
  free_string_field (&(args_info->matrixfile_arg));
  free_string_field (&(args_info->matrixfile_orig));
  free_string_field (&(args_info->gapopen_orig));
  free_string_field (&(args_info->gapextend_orig));
  free_string_field (&(args_info->nr_of_threads_orig));
  free_string_field (&(args_info->tokens_per_thread_orig));
  free_string_field (&(args_info->sequences_per_compute_chunk_orig));
  free_string_field (&(args_info->max_sequence_name_length_orig));
  free_string_field (&(args_info->max_query_sequence_length_orig));
  free_string_field (&(args_info->max_db_sequence_length_orig));



  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->databasefile_given)
    write_into_file(outfile, "databasefile", args_info->databasefile_orig, 0);
  if (args_info->queryfile_given)
    write_into_file(outfile, "queryfile", args_info->queryfile_orig, 0);
  if (args_info->profilefile_given)
    write_into_file(outfile, "profilefile", args_info->profilefile_orig, 0);
  if (args_info->matrixfile_given)
    write_into_file(outfile, "matrixfile", args_info->matrixfile_orig, 0);
  if (args_info->gapopen_given)
    write_into_file(outfile, "gapopen", args_info->gapopen_orig, 0);
  if (args_info->gapextend_given)
    write_into_file(outfile, "gapextend", args_info->gapextend_orig, 0);
  if (args_info->print_sequence_id_given)
    write_into_file(outfile, "print-sequence-id", 0, 0 );
  if (args_info->verify_algorithm_given)
    write_into_file(outfile, "verify-algorithm", 0, 0 );
  if (args_info->disable_threading_given)
    write_into_file(outfile, "disable-threading", 0, 0 );
  if (args_info->nr_of_threads_given)
    write_into_file(outfile, "nr-of-threads", args_info->nr_of_threads_orig, 0);
  if (args_info->tokens_per_thread_given)
    write_into_file(outfile, "tokens-per-thread", args_info->tokens_per_thread_orig, 0);
  if (args_info->sequences_per_compute_chunk_given)
    write_into_file(outfile, "sequences-per-compute-chunk", args_info->sequences_per_compute_chunk_orig, 0);
  if (args_info->benchmark_given)
    write_into_file(outfile, "benchmark", 0, 0 );
  if (args_info->benchmark_verbose_given)
    write_into_file(outfile, "benchmark-verbose", 0, 0 );
  if (args_info->max_sequence_name_length_given)
    write_into_file(outfile, "max-sequence-name-length", args_info->max_sequence_name_length_orig, 0);
  if (args_info->max_query_sequence_length_given)
    write_into_file(outfile, "max-query-sequence-length", args_info->max_query_sequence_length_orig, 0);
  if (args_info->max_db_sequence_length_given)
    write_into_file(outfile, "max-db-sequence-length", args_info->max_db_sequence_length_orig, 0);


  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }

  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;

  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }

  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (cmdline_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }

  return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (! args_info->databasefile_given)
    {
      fprintf (stderr, "%s: '--databasefile' ('-d') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }

  if (! args_info->matrixfile_given)
    {
      fprintf (stderr, "%s: '--matrixfile' ('-s') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }


  /* checks for dependences among options */

  return error_occurred;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given,
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n",
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n",
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);

  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;

  int override;
  int initialize;
  int check_required;
  int check_ambiguity;

  package_name = argv[0];

  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 0 },
        { "databasefile",	1, NULL, 'd' },
        { "queryfile",	1, NULL, 'q' },
        { "profilefile",	1, NULL, 'p' },
        { "matrixfile",	1, NULL, 's' },
        { "gapopen",	1, NULL, 'i' },
        { "gapextend",	1, NULL, 'e' },
        { "print-sequence-id",	0, NULL, 'u' },
        { "verify-algorithm",	0, NULL, 'V' },
        { "disable-threading",	0, NULL, 'D' },
        { "nr-of-threads",	1, NULL, 't' },
        { "tokens-per-thread",	1, NULL, 'T' },
        { "sequences-per-compute-chunk",	1, NULL, 'W' },
        { "benchmark",	0, NULL, 'b' },
        { "benchmark-verbose",	0, NULL, 'B' },
        { "max-sequence-name-length",	1, NULL, 'K' },
        { "max-query-sequence-length",	1, NULL, 'L' },
        { "max-db-sequence-length",	1, NULL, 'M' },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hd:q:p:s:i:e:uVDt:T:W:bBK:L:M:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'd':	/* A FASTA-formatted sequence database file.  */


          if (update_arg( (void *)&(args_info->databasefile_arg),
               &(args_info->databasefile_orig), &(args_info->databasefile_given),
              &(local_args_info.databasefile_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "databasefile", 'd',
              additional_error))
            goto failure;

          break;
        case 'q':	/* A single sequence file in FASTA-format.  */


          if (update_arg( (void *)&(args_info->queryfile_arg),
               &(args_info->queryfile_orig), &(args_info->queryfile_given),
              &(local_args_info.queryfile_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "queryfile", 'q',
              additional_error))
            goto failure;

          break;
        case 'p':	/* A profile file.  */


          if (update_arg( (void *)&(args_info->profilefile_arg),
               &(args_info->profilefile_orig), &(args_info->profilefile_given),
              &(local_args_info.profilefile_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "profilefile", 'p',
              additional_error))
            goto failure;

          break;
        case 's':	/* Integer similarity matrix file ( scoring matrix ).  */


          if (update_arg( (void *)&(args_info->matrixfile_arg),
               &(args_info->matrixfile_orig), &(args_info->matrixfile_given),
              &(local_args_info.matrixfile_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "matrixfile", 's',
              additional_error))
            goto failure;

          break;
        case 'i':	/* Penalty for starting alignment gap (non-positive integer).  */


          if (update_arg( (void *)&(args_info->gapopen_arg),
               &(args_info->gapopen_orig), &(args_info->gapopen_given),
              &(local_args_info.gapopen_given), optarg, 0, "-10", ARG_INT,
              check_ambiguity, override, 0, 0,
              "gapopen", 'i',
              additional_error))
            goto failure;

          break;
        case 'e':	/* Penalty for extending alignment gap (non-positive integer).  */


          if (update_arg( (void *)&(args_info->gapextend_arg),
               &(args_info->gapextend_orig), &(args_info->gapextend_given),
              &(local_args_info.gapextend_given), optarg, 0, "-2", ARG_INT,
              check_ambiguity, override, 0, 0,
              "gapextend", 'e',
              additional_error))
            goto failure;

          break;
        case 'u':	/* In addition to the score, also print the sequence-id.  */


          if (update_arg((void *)&(args_info->print_sequence_id_flag), 0, &(args_info->print_sequence_id_given),
              &(local_args_info.print_sequence_id_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "print-sequence-id", 'u',
              additional_error))
            goto failure;

          break;
        case 'V':	/* verify vector implementation against scalar implementation.  */


          if (update_arg((void *)&(args_info->verify_algorithm_flag), 0, &(args_info->verify_algorithm_given),
              &(local_args_info.verify_algorithm_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "verify-algorithm", 'V',
              additional_error))
            goto failure;

          break;
        case 'D':	/* disable all threading.  */


          if (update_arg((void *)&(args_info->disable_threading_flag), 0, &(args_info->disable_threading_given),
              &(local_args_info.disable_threading_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "disable-threading", 'D',
              additional_error))
            goto failure;

          break;
        case 't':	/* numbers of threads (normally autodetected).  */


          if (update_arg( (void *)&(args_info->nr_of_threads_arg),
               &(args_info->nr_of_threads_orig), &(args_info->nr_of_threads_given),
              &(local_args_info.nr_of_threads_given), optarg, 0, 0, ARG_INT,
              check_ambiguity, override, 0, 0,
              "nr-of-threads", 't',
              additional_error))
            goto failure;

          break;
        case 'T':	/* numbers of tokens per thread (normally autodetected).  */


          if (update_arg( (void *)&(args_info->tokens_per_thread_arg),
               &(args_info->tokens_per_thread_orig), &(args_info->tokens_per_thread_given),
              &(local_args_info.tokens_per_thread_given), optarg, 0, "5", ARG_INT,
              check_ambiguity, override, 0, 0,
              "tokens-per-thread", 'T',
              additional_error))
            goto failure;

          break;
        case 'W':	/* nr of sequences each thread are given per computation iteration ( doesn't influence the result but may influence the speed ).  */


          if (update_arg( (void *)&(args_info->sequences_per_compute_chunk_arg),
               &(args_info->sequences_per_compute_chunk_orig), &(args_info->sequences_per_compute_chunk_given),
              &(local_args_info.sequences_per_compute_chunk_given), optarg, 0, "10", ARG_INT,
              check_ambiguity, override, 0, 0,
              "sequences-per-compute-chunk", 'W',
              additional_error))
            goto failure;

          break;
        case 'b':	/* print computation speed (unit is GigaCells/s).  */


          if (update_arg((void *)&(args_info->benchmark_flag), 0, &(args_info->benchmark_given),
              &(local_args_info.benchmark_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "benchmark", 'b',
              additional_error))
            goto failure;

          break;
        case 'B':	/* print computation speed (unit is GigaCells/s) and additional information such as user time, number of db sequences that needed to use the word sized function, length of querysequence, sum of db sequence lengths, number of db sequences.  */


          if (update_arg((void *)&(args_info->benchmark_verbose_flag), 0, &(args_info->benchmark_verbose_given),
              &(local_args_info.benchmark_verbose_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "benchmark-verbose", 'B',
              additional_error))
            goto failure;

          break;
        case 'K':	/* Maximum allowed length of a sequence name.  */


          if (update_arg( (void *)&(args_info->max_sequence_name_length_arg),
               &(args_info->max_sequence_name_length_orig), &(args_info->max_sequence_name_length_given),
              &(local_args_info.max_sequence_name_length_given), optarg, 0, "256", ARG_INT,
              check_ambiguity, override, 0, 0,
              "max-sequence-name-length", 'K',
              additional_error))
            goto failure;

          break;
        case 'L':	/* Maximum allowed length of the query sequence.  */


          if (update_arg( (void *)&(args_info->max_query_sequence_length_arg),
               &(args_info->max_query_sequence_length_orig), &(args_info->max_query_sequence_length_given),
              &(local_args_info.max_query_sequence_length_given), optarg, 0, "10000", ARG_INT,
              check_ambiguity, override, 0, 0,
              "max-query-sequence-length", 'L',
              additional_error))
            goto failure;

          break;
        case 'M':	/* Maximum allowed length of any of the db sequences.  */


          if (update_arg( (void *)&(args_info->max_db_sequence_length_arg),
               &(args_info->max_db_sequence_length_orig), &(args_info->max_db_sequence_length_given),
              &(local_args_info.max_db_sequence_length_given), optarg, 0, "10000", ARG_INT,
              check_ambiguity, override, 0, 0,
              "max-db-sequence-length", 'M',
              additional_error))
            goto failure;

          break;

        case 0:	/* Long option with no short option */
          if (strcmp (long_options[option_index].name, "version") == 0) {
            cmdline_parser_print_version ();
            cmdline_parser_free (&local_args_info);
            exit (EXIT_SUCCESS);
          }

        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error_occurred += cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  return 0;

failure:

  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
